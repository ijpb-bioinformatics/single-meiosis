---
title: "Supplementary materials"
geometry: margin=1.5cm
numbersections: true
output:
  pdf_document: 
    toc: true
    toc_depth: 5
  fig_caption: true
  keep_tex: true
  html_document: 
    toc: true
    toc_depth: 6
bibliography: bibliography.bib
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
```

```{r lib, echo=FALSE}
library(tidyverse)
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(plyr)
library(purrr)
library(xtable)
library(gridExtra)
library(dplyr)
library(broom)
library(cowplot)
library(patchwork)
```


```{r data, echo=FALSE}

load("Data/TabOfSNP.Rdata")

load("Data/Tetrads_genotype_sample_30000.Rdata")

CO_data <- read.table("Data/CO.txt",h=TRUE,sep="\t") 

NCO_data <- read.table("Data/NCO.txt",h=TRUE,sep="\t")

CO_data$Genotype <- factor(CO_data$Genotype, 
                           levels = c("wt","Fa","Fi","FiFa","QAB","QFa","QFi","QFiFa"))
NCO_data$Genotype <- factor(NCO_data$Genotype, 
                            levels = c("wt","Fa","Fi","FiFa","QAB","QFa","QFi","QFiFa"))

Score <- read.table("Data/HMM_MAP_ByTetrads.txt", h=TRUE)
Score$Genotype <- factor(Score$Genotype, 
                         levels = c("wt","Fa","Fi","FiFa","QAB","QFa","QFi","QFiFa"))

load("Data/ColGenomeFeatures.Rdata")

Chrom = as.tibble(unlist(ColGenomeFeatures$ChromosomeLength[1:5]))
names(Chrom) = "xmax"
Chrom$Chr = names(ColGenomeFeatures$ChromosomeLength[1:5])
Chrom$xmin = rep(0.4, 5)
Chrom$ymin = rep(0.4, 5)
Chrom$ymax = rep(0.6, 5)

centro = as.tibble(
    data.frame(
        "Chr" = ColGenomeFeatures$ChromosomeFeatures$centromere$V1[seq(1, 10, 2)],
        "xmin" = ColGenomeFeatures$ChromosomeFeatures$centromere$V2[seq(1, 10, 2)],
        "xmax" = ColGenomeFeatures$ChromosomeFeatures$centromere$V3[seq(2, 10, 2)],
        "ymin" = rep(-0.1, 5),
        "ymax" = rep(-0.2, 5)
    )
)
hetero = as.tibble(
    data.frame(
        "Chr" = ColGenomeFeatures$ChromosomeFeatures$heterochromatine$V1,
        "xmin" = ColGenomeFeatures$ChromosomeFeatures$heterochromatine$V2,
        "xmax" = ColGenomeFeatures$ChromosomeFeatures$heterochromatine$V3,
        "ymin" = rep(
            -0.1,
            dim(ColGenomeFeatures$ChromosomeFeatures$heterochromatine)[1]
        ),
        "ymax" = rep(
            -0.2,
            dim(ColGenomeFeatures$ChromosomeFeatures$heterochromatine)[1]
        )
    )
)

```

# Supplementary methods

## Bioinformatics workflow

### Schema

### Alignment, filtering and count: Pipeline single-meiosis.sh 

Tetrad's analysis was carried out by applying the overall strategy
proposed by @Anderson2011 and implemented in the single-meiosis.sh
pipeline available at .

-   For each tetrads, sequences from the four individuals were mapped
    against a merged reference genome containing both the Columbia
    (TAIR10) and Landsberg (@Zapata2016) sequences. BWA (@Li2009bwa)       
    was used to align sequences with a set of parameters positioned to
    neither allow mismatches (or gap) nor multiple hits.

-   Alignment were filtered out to remove non specific hit and PCR
    duplicates. Such parameters ensure only the maintenance of reads
    that are specific to one of the parental genomes and also specific 
    to a single locus This parameters discards reads that span
    conversion but allowing mismatches introduced two much noises in 
    the results. This settings was the best compromise between specificity 
    and sensitivity.

-   Each alignment file was then separated by parental genomes: Col-0
    and Ler-0 to compute the number of reads covering each genome
    position thanks to the samtools mpileup programm.

### Cross with SNV: variantutils R functions [author: Charif D.]

VCF files and SNPs list (Zapata et al., 2016) were cross referenced and used as input for the HMM

### Individuals and Tetrad genotyping: HMM_model R functions [author: Robin S.]

An HMM model was implemented by S. Robin to obtain both the individuals and tetrad genotypes at each SNV position from files that compile the number of reads at each position for each individual in the tetrad (M1, M2, M3, M4). 

Notations:

-   $I = 4$ individuals forming a tetrade ($i = 1 \dots I$);
-   $C = 5$ chromosomes per individuals ($c = 1 \dots C$);
-   $T$ markers ($T_c$ markers in chromosomes $c$: $\sum_c n_c = n$,
    $t = 1 \dots n_c$);
-   $R_{ict} =$ number of reads mapped onto marker $t$ in the Col + Ler
    genome from chromosome $c$ in individual $i$;
-   $Y_{ict} =$ number of reads mapped onto marker $t$ in the Col genome from chromosome $c$ in individual $i$.

#### Individual level:

Because of the experimental setting, at each marker, the ratio
$Y_{it} / R_{it}$ is expected to be close to either:

-   1/2 (heterozygous genotype Col/Ler) or
-   1 (homozygous genotype Col)

This suggest a model with $K = 2$ hidden states with respective emission
distributions:

-   $Y_{it} \sim \mathcal{B}(R_{it}, \gamma_1)$, where
    $\gamma_1 \simeq 1/2$;
-   $Y_{it} \sim \mathcal{B}(R_{it}, \gamma_2)$, where
    $\gamma_2 \simeq 1$.

The first goal is to recover for each individual at each marker the
hidden state $$
Z_{it} \in \{1, 2\}
$$ 

#### Tetrade level

Tetrad genotype is determined by the states of the four individuals at a
given marker. Therefore, we consider the joint hidden state
$S_t \in \{1, \dots K^I\} = \{1, \dots 16\}$ for the whole tetrade at
position $t$, which is related to the four individual hidden states
$Z_{it}$ according to Table. \ref{Tab:CorrespStZit}. In the same table
$H_t$ is the number of heterozygous individuals at marker $t$. These
states can be interpreted as follows:

-   States $S_t =$ 1 and 16 ($H_t =$ 4 and 0) are expected to be absent;
-   States $S_t =$ 4, 6, 7, 10, 11 and 13 ($H_t =$ 2) are expected to be
    predominant;
-   States $S_t =$ 2, 3, 5, 8, 9, 12, 14 and 15 ($H_t$ = 1 or 3)
    correspond to NCO.

```{=tex}
\begin{table}[ht]
$$
\begin{array}{l|cccccccccccccccc}
S_t & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 \\
\hline
Z_{1t} & 1 & 2 & 1 & 2 & 1 & 2 & 1 & 2 & 1 &  2 &  1 &  2 &  1 &  2 &  1 &  2 \\
Z_{2t} & 1 & 1 & 2 & 2 & 1 & 1 & 2 & 2 & 1 &  1 &  2 &  2 &  1 &  1 &  2 &  2 \\
Z_{3t} & 1 & 1 & 1 & 1 & 2 & 2 & 2 & 2 & 1 &  1 &  1 &  1 &  2 &  2 &  2 &  2 \\
Z_{4t} & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 2 &  2 &  2 &  2 &  2 &  2 &  2 &  2 \\
\hline
H_t & 4 & 3 & 3 & 2 & 3 & 2 & 2 & 1 & 3 &  2 &  2 &  1 &  2 &  1 &  1 &  0
\end{array}
$$
\caption{Correspondence between the tetrade hidden state $S_t$ and each of the four individual hidden states $Z_{it}$, as defined by the R instruction: {\tt expand.grid((1:2),(1:2),(1:2),(1:2))}. \label{Tab:CorrespStZit}}
\end{table}
```
We used the hidden Markov model (HMM) framework where:

-   the hidden states $Z_{it}$ or $S_t$ are supposed to form a Markov
    chain and where
-   the observations $Y_{it}$ are supposed to be independent
    conditionally on the hidden states with distribution controlled by
    the corresponding hidden state.

#### HMM parameters

-   The hidden states of each individual have been considered jointly.
    Both the success probabilities ($\gamma_1, \gamma_2$) and the
    transition rates ($\lambda, \mu$) are common to al individuals,
    resulting in: $$
    \widehat{\gamma}_{1}, \widehat{\gamma}_{2},  \widehat{\lambda}, \widehat{\mu} \quad \rightarrow \text{ 4 parameters.}
    $$
-   To take into account the non homogeneous distance separating the
    marker, we allowed heterogeneous transition probabilities
    (continuous time Markov chain). The frequencies of changes from one
    state to another are given by transition rates $$
    \lambda_{k\ell}: k \rightarrow \ell.
    $$ In the binary case ($Z \in \{1, 2\}$), denoting $$
    \lambda: 1 \rightarrow 2, \qquad \mu: 2 \rightarrow 1,
    $$

#### Classification:

The inference on the hidden states is carried based on their conditional
distribution given the observations $Y = (Y_{it})$, that is $$
p_{\widehat{\theta}}(Z | Y).
$$ The classification (that is the inference of the hidden state) had
been made marker by marker. For each individual and each marker, we
obtained the {\sl posterior probability} provided by the EM alorithm. $$
\tau_{itk} = P_{\widehat{\theta}}\{Z_{it} = k | Y\}.
$$ A natural classification rule consists in using the
{\sl maximum a posteriori} (MAP) rule: $$
MAP_{it} = \arg\max_k \tau_{itk}.
$$

#### Results:

-   Chromosome
-   Position
-   MAP
-   $-log10(1-MAP_{it})$
-   MAP classification

### COs detection and classification: crossover programm 

Thanks to the marker genotype obtained by the HMM model, we then used
the crossover programm @Anderson2011 to detect and classify the CO
event. To be considered as 2 independent COs, the SNPs involved had to 
be more than 5 kilobases apart

### NCOs detection:

NCOs correspond to markers with the following states
$St=\{2,3,5,8,9,12,14,15\}$. Contiguous markers with a genotype
corresponding to only of this states and less than 2 kb apart
were considered as a single event belong to the same event.

### Tetrads analysis iteration

1.  A first analysis of all tetrads was done considering all of the SNV
    markers from @Zapata2016 (All_SNV=545481)
2.  SNVs where then filtered according to the followig criterions:

-   Removing of SNVs associated to COs that are found in several tetrads
    (file Liste_FAUX_CO.txt)
-   Removing of markers with a non 2:2 segregation in most of the tetrads 
(fichier df_Genotype_SNP_count.txt)

3.  Re-analysis of all Tetrads with a reducing list of SNV
    (Gold_Variants=522658).
4.  Sensibitity and specificity analysis (?)

### Gold variants, CO and NCO annotation

SNP have been annotated thanks to TxDb.Athaliana.BioMart.plantsmart28
database and the locateVariants function from the VariantAnnotation
package: Coding, Intron, FiveUTR, ThreeUTR, Promoter up to 1000 bases.

Regarding, heterochromatine, centromere and transposable elements, we
used a bed file (@Giraut2011)

### Track Length estimation

- median TL: Each end of the track is defined as the midpoint between the two converted SNPs with opposite genotypes. Tract length is found by calculating the distance between these two midpoints
- min TL: between the last converted SNPs 
- max TL: between the 2 flanking SNPs

### Detection power

-   For each window size
    (20,50,75,100,200,300,400,500,600,700,
    800,900,1000,1200,1500,2000,2500,3000,
    4000,5000,8000,10000)
    -   10000 sequences of this length were sampled from the genome.
    -   We computed the following statistics
        -   mean converted SNP
        -   number of window with at least one converted SNP

# Supplementary Results

## Overview of sequencing data:

```{r , out.width = "70%"}
sequencing <- read.table("Data/RawReadsCount.txt",h=TRUE) |>
    dplyr::mutate(Depth=round((readCount*2*readSize)/120000000,0))

ggplot(sequencing,aes(x=reorder(Tetrad,Depth,mean),y=Depth,color=Genotype)) + geom_point() +
    geom_point(data=Score,aes(x=Tetrad,y=MeanCov),shape = 21, colour = "black") + 
    ylim(0,150) +xlab("Tetrad's name") + ylab("Depth") + 
    ggtitle("Sequencing depth per tetrad for each individuals (M1-M4)") + theme_bw() +
    theme(axis.text.x=element_text(angle=90))

```

```{r design}
table(unique(read.table("Data/TetradsProj2TetradsPaper.txt",h=TRUE))$Genotype)
```


## Sensibility and specificity of the overall strategy

### The Score is highly correlated to the tetrads sequencing depth

```{r Score,echo=FALSE, warning=FALSE, fig.cap="Supp Fig 2"}
# Score of CO-GC

# Plot 1
p1 <- ggplot(Score, aes(x = MinCov, y = Mean.MeanLogP.GCCO)) +
  geom_point(aes(col = Genotype)) + 
  labs(title = "GCCO", x = "Depth", y = "Score") +
  geom_smooth(se = FALSE, linewidth = 0.5, linetype = 3) +
  theme(legend.position = "none")  + theme_bw()

# Plot 2
p2 <- ggplot(Score, aes(x = MinCov, y = mean.LogP.NCO)) +
  geom_point(aes(col = Genotype)) +
  labs(title = "All detected NCO", x = "Depth", y = "Score") +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.5, linetype = 3) +
  theme(legend.position = "none")  + theme_bw()

# Plot 3 (conserver la légende ici)
p3 <- ggplot(Score, aes(x = MinCov, y = NCOconfByIGV)) +
  geom_point(aes(col = Genotype)) +
  labs(title = "NCO confirmed by IGV", x = "Depth", y = "Score") +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.5, linetype = 3) +
  theme(legend.position = "none")  + theme_bw()

# Combine plots with shared legend
combined_plot <-  (p2 | p3) / p1 + 
  plot_layout(guides = 'collect') + 
  theme(legend.position = "right", 
        legend.box = "vertical", 
        legend.box.margin = margin(0, 0, 0, 10))  + theme_bw()

# Afficher le résultat
combined_plot

```

The score is positively correlated to the rate of true positive (TP) NCO.

The more the tetrad’s depth is important, the less the number of event to check
is high and the highest is the rate of TP NCO.

```{r scorePlot, out.width = "50%"}
ggplot(filter(Score,Tetrad!="QFi_Tet18"),aes(x=MinCov,y=NbEvent.NCO))+
     geom_point(aes(size=NCOconfByIGV,col=Genotype)) + xlab("Minimum Individuals depth in Tetrad") + ylab("Number of NCO events") +
    guides(col = guide_legend(ncol = 3),size=guide_legend(ncol = 3)) + theme_bw()
```


## Gold SNPs descriptiv statistics:

```{r SNPstat, caption="suptable2"}
TabOfSNP |> dplyr::group_by(Chr) %>% dplyr::summarise(max=max(diff(Pos)),mean=mean(diff(Pos)),median=median(diff(Pos))) 
```


## Tetrads Genotypes:

```{r figure1, echo=FALSE}
# Define the function
plot_tetrad <- function(tetrad_name, CO_data, Tetrads_genotype) {
    
    # Filter CO data based on the tetrad_name input and group by specified columns
    CO_filtered <- CO_data |>
        dplyr::filter(Tetrad == tetrad_name) |>
        dplyr::group_by(Tetrad, Chr, Chromatid1, Chromatid2) |>
        dplyr::count() |>
        dplyr::arrange(Tetrad, Chr, desc(n)) |>
        dplyr::group_by(Tetrad, Chr) |>
        dplyr::slice(1)
    
    # Get the corresponding genotype data for the tetrad
    genotype_data2plot <- Tetrads_genotype[[tetrad_name]]
    
    # Function to reorder chromatids
    reorder_chromatids <- function(chromatid1, chromatid2) {
        positions <- 1:4
        positions[c(2, 3)] <- c(chromatid1, chromatid2)
        positions[c(1, 4)] <- setdiff(1:4, c(chromatid1, chromatid2))
        return(positions)
    }
    
    
    # Create a list of chromosome tables
    nb_points <- table(genotype_data2plot$Chr)
    y2 <- list()
    tmp <- list()
    
    chromosomes <- unique(CO_filtered$Chr)
    
    for (i in chromosomes) {
        ind <- filter(CO_filtered, Chr == i)
        tmp[[i]] <- reorder_chromatids(ind$Chromatid1, ind$Chromatid2)
        y2[[i]] <- rep(tmp[[i]], nb_points[i] / 4)
    }
    
    # Assign reordered positions to the plot data
    genotype_data2plot$y2 <- unlist(y2)
    
    # Filter the Cross data based on the tetrad_name input
    Cross <- CO_data |>
        filter(Tetrad == tetrad_name)
    
    # Reorder chromatid positions in Cross data
    for (j in 1:nrow(Cross)) {
        tmp1 <- tmp[[Cross[j, ]$Chr]]
        Cross$Chromatid1Pos[j] <- tmp1[Cross[j, ]$Chromatid1]
        Cross$Chromatid2Pos[j] <- tmp1[Cross[j, ]$Chromatid2]
    }
    
    # Arrange plot data based on chromosome and position
    genotype_data2plot <- genotype_data2plot |>
        arrange(Chr, Pos, y2)
    
    # Generate the plot using ggplot2
    ggplot(genotype_data2plot) +
        geom_point(
            aes(x = Pos, y = y2, color = Genotype),
            shape = 15,
            cex = 0.9,
            show.legend = FALSE
        ) +
        geom_segment(
            data = Cross,
            aes(
                x = flankingSNP.F1,
                y = Chromatid1Pos,
                xend = flankingSNP.F2,
                yend = Chromatid2Pos
            ),
            size = 1,
            color = "darkblue"
        ) +
        facet_grid(Chr ~ Tetrad) +
        scale_colour_manual(values = c("red", "black")) +
        scale_x_continuous(labels = function(x) x / 1e6,  
                     name = "Position (Mb)") + 
        theme(
            axis.ticks.y = element_blank(),
            axis.title.y = element_blank(),
            axis.title.x = element_blank(),
            axis.ticks.x = element_blank(),
            axis.text.y=element_blank(),
            strip.background = element_blank(),
            panel.grid.minor = element_blank(),
            panel.grid.major = element_blank(),
            strip.placement = "outside",
            panel.background = element_rect(fill = NA),
            strip.text.x = element_text(size = 20, colour = "black"),
            panel.spacing = unit(0.5, "lines")
        )
}

tetrad_names=c(
"wt_Tet1", "wt_Tet2", "wt_Tet3", "wt_Tet4", "wt_Tet5", "Fi_Tet10","Fa_Tet6","Fa_Tet7","Fi_Tet8","Fi_Tet9","QAB_Tet11",
"QAB_Tet12","QAB_Tet13","QFa_Tet16","FiFa_Tet14","FiFa_Tet15",
"QFi_Tet17","QFi_Tet18","QFiFa_Tet19","QFiFa_Tet20")

plots_genotype <- lapply(tetrad_names, function(tetrad) {
  plot_tetrad(tetrad_name = tetrad, CO_data, Tetrads.genotype)
})
# plot
```

```{r plot1, echo=FALSE}
grid.arrange(grobs=plots_genotype[1:2],ncol=1)
```

```{r plot2, echo=FALSE}
grid.arrange(grobs=plots_genotype[3:4],ncol=1)
```

```{r plot3, echo=FALSE}
grid.arrange(grobs=plots_genotype[5:6],ncol=1)
```

```{r plot4, echo=FALSE}
grid.arrange(grobs=plots_genotype[7:8],ncol=1)
```

```{r plot5, echo=FALSE}
grid.arrange(grobs=plots_genotype[9:10],ncol=1)
```

```{r plot6, echo=FALSE}
grid.arrange(grobs=plots_genotype[11:12],ncol=1)
```

```{r plot7, echo=FALSE}
grid.arrange(grobs=plots_genotype[13:14],ncol=1)
```

```{r plot8, echo=FALSE}
grid.arrange(grobs=plots_genotype[15:16],ncol=1)
```

```{r plot9, echo=FALSE}
grid.arrange(grobs=plots_genotype[17:18],ncol=1)
```

```{r plot10, echo=FALSE}
grid.arrange(grobs=plots_genotype[19:20],ncol=1)
```

## Distribution of detected CO and NCO along the genome:

```{r plot_event, echo=FALSE, eval=TRUE}
plot_event <- function(tetrad_name, CO_data, NCO_data, Chrom, hetero, centro) {
    
    # Filtrer les données pour les différents types d'événements
    COPLOT <- dplyr::filter(CO_data, GC.nbSNP == 0, Tetrad == tetrad_name)
    COPLOT$x <- round(COPLOT$flankingSNP.F1, 0)
    COPLOT$y <- rep(0.8, nrow(COPLOT))
    
    GCCOPLOT <- dplyr::filter(CO_data, GC.nbSNP != 0, Tetrad == tetrad_name)
    GCCOPLOT$y <- rep(0.8, nrow(GCCOPLOT))
    
    NCOPLOT <- dplyr::filter(NCO_data, Tetrad == tetrad_name)
    NCOPLOT$y <- rep(0.2, nrow(NCOPLOT))
    
    # Création du graphique avec ggplot
    ggplot(data = Chrom) +
        geom_rect(
            mapping = aes(
                xmin = xmin,
                xmax = xmax,
                ymin = ymin,
                ymax = ymax
            ),
            colour = "grey"
        ) +
        geom_rect(
            data = hetero,
            mapping = aes(
                xmin = xmin,
                xmax = xmax,
                ymin = 0.45,
                ymax = 0.55
            ),
            fill = "chartreuse4",
            color = "chartreuse4"
        ) +
        geom_rect(
            data = centro,
            mapping = aes(
                xmin = xmin,
                xmax = xmax,
                ymin = 0.45,
                ymax = 0.55
            ),
            fill = "chartreuse",
            color = "chartreuse"
        ) +
        facet_grid(Chr ~ Tetrad) +
        ylim(c(0, 1)) +
        scale_x_continuous(labels = function(x) x / 1e6,  
                     name = "Position (Mb)") + 
        geom_point(
            data = COPLOT,
            aes(x = x, y = y),
            shape = 25,
            size = 2,
            color = "red",
            fill = "red",
            show.legend = TRUE
        ) +
        geom_point(
            data = GCCOPLOT,
            aes(x = flankingSNP.F1, y = y),
            shape = 25,
            size = 2,
            color = "orange",
            fill = "red",
            show.legend = TRUE
        ) +
        geom_point(
            data = NCOPLOT,
            aes(x = event.start, y = y),
            shape = 17,
            size = 2,
            color = "pink",
            fill = "pink",
            show.legend = TRUE
        ) +
        scale_color_manual(
            name = "Type of Event",
            labels = c("CO", "GCCO", "NCO"),
            values = c(
                "red" = "red",
                "orange" = "orange",
                "pink" = "pink"
            )
        ) +
        theme_minimal() +
        theme(
            strip.text.y = element_text(angle = 90),
            axis.ticks.y = element_blank(),
            axis.title.y = element_blank(),
            axis.title.x = element_blank(),
            axis.text.y = element_blank(),
            strip.background = element_blank(),
            panel.grid.minor = element_blank(),
            panel.grid.major = element_blank(),
            strip.placement = "outside",
            #panel.background = element_rect(fill = NA),
            legend.position = "bottom"
        )
}

plots_tetrads <- lapply(tetrad_names, function(tetrad) {
  plot_event(tetrad_name = tetrad, CO_data, NCO_data, Chrom, hetero, centro)
})

# Exemple d'appel de la fonction
grid.arrange(grobs = plots_tetrads[1:4], ncol = 2)
```

```{r plot_event2, echo=FALSE, eval=TRUE}
grid.arrange(grobs = plots_tetrads[5:8], ncol = 2)
```

```{r plot_event3, echo=FALSE, eval=TRUE}
grid.arrange(grobs = plots_tetrads[9:12], ncol = 2)
```

```{r plot_event4, echo=FALSE, eval=TRUE}
grid.arrange(grobs = plots_tetrads[13:16], ncol = 2)
```

```{r plot_event5, echo=FALSE, eval=TRUE}
grid.arrange(grobs = plots_tetrads[17:20], ncol = 2)
```

## Number of detected events per tetrads and genotypes

```{r nbCO, fig=TRUE, echo=FALSE}
nb_CO <- CO_data |> dplyr::group_by(Genotype,Tetrad) |> dplyr::count() 

# Générer le graphique à points avec 'jitter'
pCO <- ggplot(nb_CO) + 
  geom_jitter(aes(x = Genotype, y = n, color = Genotype), width = 0.2, size = 1.5) +  # Ajout de jitter
  labs(title = "", 
       x = "", 
       y = "# of COs per Tetrad") + 
  theme_bw() + 
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y = element_text(size = 8), 
    legend.position = "none",
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    panel.grid.minor = element_blank()
  )
```

```{r nbCO2}
GC.nbSNP <- CO_data |>
  dplyr::mutate("is.GCCO" = as.numeric(GC.nbSNP != 0)) |>  # Créer une colonne is.GCCO
  dplyr::group_by(Genotype) |>  # Grouper par Genotype
  dplyr::count(is.GCCO) |>  # Compter les occurrences de is.GCCO pour chaque Genotype
  dplyr::mutate(percentage = n / sum(n) * 100) 

GC.nbSNP_summary <- GC.nbSNP %>%
  dplyr::group_by(Genotype) %>%
  dplyr::summarise(total_n = sum(n)) 

pGCCO <- ggplot(GC.nbSNP) + 
    geom_bar(aes(x = Genotype, y = percentage , fill=as.factor(is.GCCO)), stat = "identity") + 
    scale_fill_manual(values = c("darkred","red"), name = "", 
                      labels = c("without GC", "with GC"))  + 
    theme_bw() +
    theme(
        plot.margin = margin(t = 5, r = 5, b = 0, l = 5) , 
        axis.text.x = element_text(angle = 45, hjust = 1) , 
        axis.text.y = element_text(size = 8), 
        legend.position = "right",
        legend.box="vertical")+ 
    labs( x = "Genotype", y = "% of COs") +
    scale_y_continuous(labels = scales::percent_format(scale = 1)) +
    geom_text(data=GC.nbSNP_summary,aes(x = Genotype, y = 104, label = total_n), size = 3) 

```

```{r NCOcoo,echo=FALSE}

nb_NCO <- NCO_data |> dplyr::group_by(Genotype,Tetrad) |> dplyr::count() |> dplyr::arrange(desc(n),Genotype,Tetrad)

nb_NCO$Genotype <- factor(nb_NCO$Genotype, levels = c("wt", "Fa","Fi","FiFa","QAB","QFa","QFi","QFiFa"))

# Générer le graphique à points avec 'jitter'
pNCO <- ggplot(nb_NCO) + 
  geom_jitter(aes(x = Genotype, y = n, color = Genotype), width = 0.2, size = 1.5) +  # Ajout de jitter
  labs(title = "", 
       x = "Genotype", 
       y = "# of NCOs per Tetrads") + 
  theme_bw() + 
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y = element_text(size = 8),
    legend.position = "none",
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    panel.grid.minor = element_blank()
  )


```

```{r nb_CO, echo=FALSE, fig.cap="fig2"}
nb_CO <- CO_data |> dplyr::group_by(Genotype,Tetrad) |> dplyr::count() |> dplyr::arrange(desc(n),Genotype,Tetrad)
nb_CO$Genotype <- factor(nb_CO$Genotype, 
                         levels = c("wt", "Fa","Fi","FiFa","QAB","QFa","QFi","QFiFa"))

pCONCO <- merge(nb_NCO,nb_CO,by=c("Genotype","Tetrad")) |>
    dplyr::mutate(sum=n.x+n.y) |> dplyr::select(Genotype,Tetrad,sum) |>
    ggplot() + geom_jitter(aes(x = Genotype, y = sum , color = Genotype),
                           width = 0.2, size = 1.5) + ylim(0, 100) +
  labs(title = "",
       x = "",
       y = "# of COs + NCOs per Tetrads") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none",
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    panel.grid.minor = element_blank()
  )

# fig2 <- grid.arrange(pCO,pNCO,pCONCO,pGCCO, ncol = 3, nrow=2)
# fig2

combined_plot <-  (pCO | pNCO | pCONCO) / (pGCCO | plot_spacer()) +
  theme(
        legend.box.margin = margin(0, 0, 0, 10))  + theme_bw()

# Afficher le résultat
combined_plot

ggsave(filename="fig2.pdf", plot=combined_plot)
```


## Number of events and converted SNP per Tetrads

```{r NCO.Nbsnp, echo=FALSE}

p1 <- ggplot(NCO_data) + 
  geom_boxplot(aes(x = Genotype, y = nbSNP, fill = Genotype), outliers=FALSE, width = 0.6, alpha = 0.5) +  # Diagramme en violon
  geom_jitter(aes(x = Genotype, y = nbSNP, color = Genotype), width = 0.2, size = 1, alpha = 0.7) +  # Points ajoutés avec jitter
  stat_summary(aes(x = Genotype, y = nbSNP, color = Genotype), fun = mean, geom = "point", size = 1.5, shape = 18,color="black") +  # Médianes ajoutées
  labs(title = "", 
       x = "Genotype", 
       y = "Distribution of the number of SNP converted") + 
  theme_bw() + 
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), 
    legend.position = "none",
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    panel.grid.minor = element_blank()
  ) 

```

```{r CO.NbSNP,echo=FALSE, fig.cap="Supp Fig4"}
Nb_snp_tetrad_CO <- CO_data |> dplyr::select(Genotype,Tetrad,GC.nbSNP) |>  dplyr::group_by(Genotype,Tetrad)  |> dplyr::summarise(sum=sum(GC.nbSNP)) 

Nb_snp_tetrad_NCO <- NCO_data |> dplyr::select(Genotype,Tetrad,nbSNP) |>  
    dplyr::group_by(Genotype,Tetrad)  |> dplyr::summarise(sum=sum(nbSNP)) 

p2 <- merge(Nb_snp_tetrad_CO,Nb_snp_tetrad_NCO,by=c("Genotype","Tetrad")) |> 
    dplyr::mutate(sum=sum.x+sum.y) |> dplyr::select(Genotype,Tetrad,sum) |> 
    ggplot() + 
    geom_jitter(aes(x = Genotype, y = sum , color = Genotype),
                width = 0.4, size = 1.5,alpha = 0.7) +  
    stat_summary(aes(x = Genotype, y = sum, color = Genotype), 
                 fun = mean, geom = "point", size = 1.5, shape = 18,color="black") + 
    ylim(0, 150) + 
  labs(title = "", 
       x = "Genotype", 
       y = "Number of SNP converted per meiosis") + 
  theme_bw() + 
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), 
    legend.position = "none",
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    panel.grid.minor = element_blank()
  )

grid.arrange(p1,p2,ncol=2)
```

## Track Length analysis

Dans l'analyse précédente, on avait pris cette decision:

When the two SNPs flanking the conversion events are at a cumulativ
distance greater than 1 kb (ie twice the distance separating on average
2 snps) then we consider that the estimate of the size of the conversion
is not precise enough to be keeped for the analysis.

```{r TLdata, echo=FALSE}
TL.NCO <- dplyr::select(NCO_data,"Tetrad","Genotype","medianD") |> dplyr::mutate("Type"="NCO") 
TL.CO  <- dplyr::select(CO_data,"Tetrad","Genotype","GC_tracLength") |> dplyr::rename(medianD="GC_tracLength") |> dplyr::filter(medianD > 0) |> dplyr::mutate("Type"="CO") 


data <- rbind(TL.NCO, TL.CO)
```


### Descriptiv statistics:

#### NCO

```{r NCOdesc, results='asis'}
NCOdesc <- NCO_data %>% group_by(Genotype) %>% dplyr::summarise(n=n(),median.mean=mean(medianD),minTL.mean=mean(minTL),maxTL.mean=mean(maxTL))
print(xtable(NCOdesc,caption="table1"))
```
#### CO

```{r COdesc, results='asis', align='left'}
CO_data_bis <- read.table("Data/CO_Description.txt",h=TRUE,sep="\t") 
CO_data_bis$Genotype <- factor(CO_data_bis$Genotype, levels = c("wt", "Fa","Fi","FiFa","QAB","QFa","QFi","QFiFa"))
COdesc <- CO_data_bis %>% filter(is.gc==TRUE) %>% group_by(Genotype) %>% dplyr::summarise(n=n(),median.mean=mean(medianD),minTL.mean=mean(minTL),maxTL.mean=mean(maxTL))
print(xtable(COdesc,caption="table1"))
```

#### Comparison of CO and NCO TL within Genotype

```{r TLtest, fig.align='left'}

# Combiner les données 
data <- rbind(TL.NCO, TL.CO)

# Effectuer le test de Wilcoxon pour chaque Genotype
wilcox_wtOther_co <- data |>
  dplyr::group_by(Genotype) |>
  dplyr::filter(dplyr::n_distinct(Type) == 2) |> 
  tidyr::nest() |> 
  dplyr::mutate(wilcox_test = purrr::map(data, ~ wilcox.test(medianD ~ Type, data = .x))) |>
  dplyr::mutate(wilcox_test_tidy = purrr::map(wilcox_test, broom::tidy)) |> 
  tidyr::unnest(wilcox_test_tidy) |> dplyr::mutate(p.adjust = p.adjust(p.value, method = "BH")) |>
     dplyr::mutate(significant = ifelse( p.adjust < 0.05, "*", ""))

# Créer le graphique avec les types côte à côte
    
p1 <- data %>%
  ggplot(aes(x = Type, y = medianD,fill=Type)) + scale_y_log10() +
  geom_boxplot(width = 0.8, alpha = 0.5,outliers=FALSE) + 
  geom_jitter( width=0.2, size = 0.7, alpha = 0.7) + 
    stat_summary( fun.y = "mean", geom = "point", size = 2, shape = 18,color="red") + 
  labs(
    title = "Track Length by Genotype and Type", 
    x = "Type", 
    y = "Log10(Track Length)"
  ) + 
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), 
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black"),
    panel.grid.minor = element_blank(),
    legend.position = "right"
  ) +
  facet_wrap(~ Genotype, ncol=8, scales = "fixed")

p1
```


```{r TLtab, results='asis', echo=FALSE, caption="table1", message=FALSE}
print(xtable(wilcox_wtOther_co[,-c(2:3,6)]))
```


### Comparaison of the CO TL: between wt and each genotype

```{r COwt, echo=FALSE}
wt_data <- data %>% filter(Genotype == "wt", Type=="CO")
other_genotypes_data <- data %>% filter(Genotype != "wt", Type=="CO")

wilcox_wtOther_co <- other_genotypes_data |>
  dplyr::group_by(Genotype) |>
  tidyr::nest() |> 
  dplyr::mutate(wilcox_test = purrr::map(data, ~wilcox.test(wt_data$medianD, .$medianD)))|>
  dplyr::mutate(wilcox_test_tidy = purrr::map(wilcox_test, broom::tidy)) %>%  # Organiser les résultats
  tidyr::unnest(wilcox_test_tidy) %>% dplyr::mutate(p.adjust = p.adjust(p.value, method = "BH")) |>
     mutate(significant = ifelse( p.adjust < 0.05, "*", ""))
```

```{r coStat, results='asis', echo=FALSE, caption="table1", message=FALSE}
print(xtable(wilcox_wtOther_co[,-c(2:3,6)]))
```

### Comparaison of the NCO TL: between wt and each genotype

```{r NCOwt, echo=FALSE}
wt_data <- data %>% filter(Genotype == "wt", Type=="NCO")
other_genotypes_data <- data %>% filter(Genotype != "wt", Type=="NCO")

wilcox_wtOther_nco <- other_genotypes_data |>
  dplyr::group_by(Genotype) |>
  tidyr::nest() |> 
  dplyr::mutate(wilcox_test = purrr::map(data, ~wilcox.test(wt_data$medianD, .$medianD)))|>
  dplyr::mutate(wilcox_test_tidy = purrr::map(wilcox_test, broom::tidy)) %>%  # Organiser les résultats
  tidyr::unnest(wilcox_test_tidy) %>% dplyr::mutate(p.adjust = p.adjust(p.value, method = "BH")) |>
     mutate(significant = ifelse( p.adjust < 0.05, "*", ""))
```

```{r ncoStat, results='asis', echo=FALSE,  message=FALSE}
print(xtable(wilcox_wtOther_nco[,-c(2:3,6)],caption="table1"))
```


## Distribution of CO and NCO in features

```{r TabOfSNP, echo=FALSE}

GCCO_data <- CO_data %>% dplyr::filter(GC.nbSNP > 0)

tmp = list()
for (i in 1:dim(GCCO_data)[1]) {
    tmp[[i]] = dplyr::filter(TabOfSNP, 
                      Chr == GCCO_data[i, "Chr"], 
                      Pos > GCCO_data[i, "flankingSNP.F1"], 
                      Pos < GCCO_data[i, "flankingSNP.F2"])
    tmp[[i]]$id_CO <- GCCO_data[i, "Tetrad.CO.Event"]
}
GCCOannot <- do.call("rbind", tmp)

CO_data <- CO_data %>% filter(GC.nbSNP == 0)

tmp = list()
for (i in 1:dim(CO_data)[1]) {
    tmp[[i]] = filter(TabOfSNP, 
                      Chr == CO_data[i, "Chr"], 
                      Pos >= CO_data[i, "flankingSNP.F1"], 
                      Pos <= CO_data[i, "flankingSNP.F2"])
    tmp[[i]]$id_CO <- CO_data[i, "Tetrad.CO.Event"]
}
COannot <- do.call("rbind", tmp)

tmp = list()
for (i in 1:dim(NCO_data)[1]) {
    tmp[[i]] = filter(TabOfSNP, 
                      Chr == NCO_data[i, "Chr"], 
                      Pos > NCO_data[i, "event.start"], 
                      Pos < NCO_data[i, "event.stop"])
    tmp[[i]]$id_NCO <- NCO_data[i, "Tetrad.NCO.Event"]
}
NCOannot <- do.call("rbind", tmp)

```

## nb SNP annot

```{r TestAnnotTL , echo=FALSE}
intronOcc<-base::rbind(table(GCCOannot$is.Intron)[2],
                       table(COannot$is.Intron)[2],
                       table(NCOannot$is.Intron)[2])
dimnames(intronOcc)[[2]]="Intron"

utr3Occ<-as.matrix(c(table(GCCOannot$is.ThreeUTR)[2],
                     table(COannot$is.ThreeUTR)[2],
                     table(NCOannot$is.ThreeUTR)[2]))
dimnames(utr3Occ)[[1]]=NULL
dimnames(utr3Occ)[[2]]="UTR3"

utr5Occ<-as.matrix(c(table(GCCOannot$is.FiveUTR)[2],
                     table(COannot$is.FiveUTR)[2],
                     table(NCOannot$is.FiveUTR)[2]))
dimnames(utr5Occ)[[1]]=NULL
dimnames(utr5Occ)[[2]]="UTR5"

TEOcc<-as.matrix(c(table(GCCOannot$is.TE)[2],
                   table(COannot$is.TE)[2],
                   table(NCOannot$is.TE)[2]))
dimnames(TEOcc)[[1]]=NULL
dimnames(TEOcc)[[2]]="TE"

HeteroOCC<-as.matrix(c( table(GCCOannot$is.Hetero[-which(GCCOannot$is.TE==TRUE)])[2],
                       table(COannot$is.Hetero[-which(COannot$is.TE==TRUE)])[2],
                        table(NCOannot$is.Hetero[-which(NCOannot$is.TE==TRUE)])[2]))
dimnames(HeteroOCC)[[1]]=NULL
dimnames(HeteroOCC)[[2]]="Hetero"
HeteroOCC[2]=0

codingOcc<-as.matrix(c(table(GCCOannot$is.Coding)[2],
                       table(COannot$is.Coding)[2],
                       table(NCOannot$is.Coding)[2]))
dimnames(codingOcc)[[1]]=NULL
dimnames(codingOcc)[[2]]="Coding"

promoterOcc<-as.matrix(c(table(GCCOannot$is.Promoter)[2],
                       table(COannot$is.Promoter)[2],
                       table(NCOannot$is.Promoter)[2]))
dimnames(promoterOcc)[[1]]=NULL
dimnames(promoterOcc)[[2]]="Promoter"

Occ <- base::cbind(utr3Occ, utr5Occ ,intronOcc, codingOcc,TEOcc,HeteroOCC,promoterOcc)
dimnames(Occ)[[1]]<-c("GCCO","CO","NCO")
Occ[-2,]

```

## nb Event Annot

```{r TestAnnotTLevent, echo=FALSE}
# INTRON

Intron.event<-as.matrix(c(
                       table(table(GCCOannot$is.Intron,GCCOannot$id_CO)[2,] != 0)["TRUE"],
                       table(table(COannot$is.Intron,COannot$id_CO)[2,] != 0)["TRUE"],
                       table(table(NCOannot$is.Intron,NCOannot$id_NCO)[2,] != 0)["TRUE"]))
dimnames(Intron.event)[[2]]="Intron"

UTR5.event<-as.matrix(c(
                       table(table(GCCOannot$is.FiveUTR,GCCOannot$id_CO)[2,] != 0)["TRUE"],
                       table(table(COannot$is.FiveUTR,COannot$id_CO)[2,] != 0)["TRUE"],
                       table(table(NCOannot$is.FiveUTR,NCOannot$id_NCO)[2,] != 0)["TRUE"]))
dimnames(UTR5.event)[[2]]="UTR5"

UTR3.event<-as.matrix(c(
                       table(table(GCCOannot$is.ThreeUTR,GCCOannot$id_CO)[2,] != 0)["TRUE"],
                       table(table(COannot$is.ThreeUTR,COannot$id_CO)[2,] != 0)["TRUE"],
                       table(table(NCOannot$is.ThreeUTR,NCOannot$id_NCO)[2,] != 0)["TRUE"]))
dimnames(UTR3.event)[[1]]=NULL
dimnames(UTR3.event)[[2]]="UTR3"

# TE
TEOcc.event<-as.matrix(c(
                   table(table(GCCOannot$is.TE,GCCOannot$id_CO)[2,]!=0)["TRUE"],
                   table(table(COannot$is.TE,COannot$id_CO)[2,]!=0)["TRUE"],
                   table(table(NCOannot$is.TE,NCOannot$id_NCO)[2,]!=0)["TRUE"]))
dimnames(TEOcc.event)[[1]]=NULL
dimnames(TEOcc.event)[[2]]="TE"


HeteroOCC.event<-as.matrix(c( 
                        table(table(GCCOannot$is.Hetero,GCCOannot$id_CO)[2,] !=0 )["TRUE"],
                        #table(table(COannot$is.Hetero,COannot$id_CO)[2,] !=0 )["TRUE"],
                        0,
                        table(table(NCOannot$is.Hetero,NCOannot$id_NCO)[2,] !=0 )["TRUE"]))
dimnames(HeteroOCC.event)[[1]]=NULL
dimnames(HeteroOCC.event)[[2]]="Hetero"

codingOcc.event<-as.matrix(c(
                        table(table(GCCOannot$is.Coding,GCCOannot$id_CO)[2,] !=0)["TRUE"],
                       table(table(COannot$is.Coding,COannot$id_CO)[2,] !=0)["TRUE"],
                       table(table(NCOannot$is.Coding,NCOannot$id_NCO)[2,] !=0)["TRUE"]))
dimnames(codingOcc.event)[[1]]=NULL
dimnames(codingOcc.event)[[2]]="Coding"

promoterOcc.event<-as.matrix(c(
                        table(table(GCCOannot$is.Promoter,GCCOannot$id_CO)[2,] !=0)["TRUE"],
                       table(table(COannot$is.Promoter,COannot$id_CO)[2,] !=0)["TRUE"],
                       table(table(NCOannot$is.Promoter,NCOannot$id_NCO)[2,] !=0)["TRUE"]))
dimnames(promoterOcc.event)[[1]]=NULL
dimnames(promoterOcc.event)[[2]]="Promoter"


Occ.event <- base::cbind(UTR3.event, UTR5.event, Intron.event,codingOcc.event,TEOcc.event,HeteroOCC.event,promoterOcc.event)
dimnames(Occ.event)[[1]]<-c("GCCO","CO","NCO")
Occ.event
```

## Distribution of SNP in features

The datamart **TxDb.Athaliana.BioMart.plantsmart28** was used to annotate
the SNP in the different features of the genome thanks to the locateVariants function from the VariantAnnotation package.
 


```{r txdb}
library(TxDb.Athaliana.BioMart.plantsmart28)
txdb <- TxDb.Athaliana.BioMart.plantsmart28
txdb <- renameSeqlevels( txdb, c("Chr1","Chr2","Chr3","Chr4","Chr5","Mt","Pt"))

# Introns
introns <- intronicParts(txdb)
SumIntronsLength <- sum(width(introns))
NbSNPinIntrons <- dplyr::filter(TabOfSNP,is.Gold==TRUE,is.Intron==TRUE) |> dplyr::count()

# Exons
exons <- exonicParts(txdb)
SumExonsLength <- sum(width(exons))
NbSNPinExons <- dplyr::filter(TabOfSNP,is.Gold==TRUE,is.Coding==TRUE) |> dplyr::count()

# fiveUTR
fiveUTR <- fiveUTRsByTranscript(txdb)
SumfiveUTRLength <- sum(width(unlist(fiveUTR)))
NbSNPinFiveUTR<- dplyr::filter(TabOfSNP,is.Gold==TRUE,is.FiveUTR ==TRUE) |> dplyr::count()

# threeUTR
threeUTR <- threeUTRsByTranscript(txdb)
SumthreeUTRLength <- sum(width(unlist(threeUTR)))
NbSNPinThreeUTR<- dplyr::filter(TabOfSNP,is.Gold==TRUE,is.ThreeUTR ==TRUE) |> dplyr::count()

# Centro
centro = ColGenomeFeatures$ChromosomeFeatures$centromere
names(centro)=c("chrom","start","end","info")
centro <- as(centro,"GRanges")
SumCentroLength <- sum(width(centro))
NbSNPinCentro<- dplyr::filter(TabOfSNP,is.Gold==TRUE,is.Centro ==TRUE) |> dplyr::count()

# hetero
hetero=ColGenomeFeatures$ChromosomeFeatures$heterochromatine
names(hetero)=c("chrom","start","end","info")
hetero <- as(hetero,"GRanges")
SumHeteroLength <- sum(width(hetero))
NbSNPinHetero<- dplyr::filter(TabOfSNP,is.Gold==TRUE,is.Hetero ==TRUE) |> dplyr::count()

# TE
te <-ColGenomeFeatures$ChromosomeTransposons$transposable_element[,c(1,4,5,3)]
names(te)=c("chrom","start","end","info")
te <- as(te,"GRanges")
SumTELength <- sum(width(te))
NbSNPinTE<- dplyr::filter(TabOfSNP,is.Gold==TRUE,is.TE ==TRUE) |> dplyr::count()

# Promoter
AppSumPromoterLength <- length(unique(unlist(mcols(exonicParts(txdb))$gene_id))) * 1000
NbSNPinPromoter<- dplyr::filter(TabOfSNP,is.Gold==TRUE,is.Promoter ==TRUE) |> dplyr::count()


# Summary

Compartiments <- c("Introns","Exons","5'UTR","3'UTR","Centromere","Heterochromatin","TE","Promoter")
SumLength <- c(SumIntronsLength,SumExonsLength,SumfiveUTRLength,SumthreeUTRLength,SumCentroLength,SumHeteroLength,SumTELength, AppSumPromoterLength)
NbSNP <- as.vector(c(NbSNPinIntrons$n,NbSNPinExons$n,NbSNPinFiveUTR$n,NbSNPinThreeUTR$n,NbSNPinCentro$n,NbSNPinHetero$n,NbSNPinTE$n,NbSNPinPromoter$n))
feat.prop=SumLength/sum(SumLength)*100
snp.prop=NbSNP/sum(NbSNP)*100
Features.df <- data.frame(Compartiments,SumLength,NbSNP,feat.prop,snp.prop)
Features.df <- Features.df[-5,]
Features.df$Compartiments <- c("Intron","Coding","UTR5","UTR3","Hetero","TE","Promoter")

tOcc <- as.data.frame(t(Occ))
tOcc$Compartiments <- row.names(tOcc)
tOcc.event <- as.data.frame(t(Occ.event))
tOcc.event$Compartiments <- row.names(tOcc.event)


feat1 <- right_join(Features.df,tOcc,by="Compartiments", suffix=c("",".snp"))
feat2 <- right_join(feat1,tOcc.event,by="Compartiments", suffix=c("",".event"))

row.names(feat2) <- feat2$Compartiments
feat2 <- dplyr::select(feat2,-CO)

```

```{r printAnnot,results='asis',align='left'}
print(xtable(feat2))
```


```{r plotcomp}
rr <- feat2 %>% dplyr::select(.,"feat.prop","snp.prop")
rr$features <- row.names(rr)
rr <- rr %>% dplyr::select(.,"features","feat.prop","snp.prop")

data_long <- rr %>%
  tidyr::pivot_longer(cols = c(feat.prop, snp.prop), names_to = "Measure", values_to = "Proportion")

# Création du graphique avec ggplot2
p3  <- ggplot(data_long, aes(x = features, y = Proportion, fill = Measure)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Features", y = "Proportion", fill = "Type",
       title = "SNP Distribution in Features Compared to Feature Size") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10)) +  
  scale_fill_manual(values = c("feat.prop"="green","snp.prop"="darkgreen"))
```

The number of converted SNP per features (summing up all tetrads results) 
is compared to the number of SNP awaited for each feature if the distribution
follow the SNP distribution in features.


```{r plotall, fig.cap="fig4"}

data_long <- feat2 %>%
     pivot_longer(cols = c(GCCO, GCCO.event, CO.event,NCO,NCO.event), 
                  names_to = "Variable", 
                  values_to = "Value")

rr <- t(feat2 %>% dplyr::select(.,"NbSNP","GCCO","NCO","SumLength"))
res <- chisq.test(rr[2:3,],p=rr$NbSNP/sum(rr$SumLength))
disSNP_res <- as.data.frame(rbind(res$observed, res$expected)) 
disSNP_res$Type=(c("GCCO.Observed","NCO.Observed","GCCO.Expected","NCO.Expected"))
disSNP_res_long <- disSNP_res %>%
  pivot_longer(cols = -Type, names_to = "Features", values_to = "Count")

p4 <- ggplot(disSNP_res_long, aes(x = Features, y = Count, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +  
  labs(x = "Features", y = "# of converted SNP (sum of all tetrads)", fill = "Type") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10)) +  
  scale_fill_manual(values = c("GCCO.Observed" = "red", "GCCO.Expected" = "darkred",
                               "NCO.Observed" = "orange", "NCO.Expected" = "darkorange"))

grid.arrange(p3,p4,ncol=1)

ggsave(filename="fig4.pdf", plot=grid.arrange(p3,p4,ncol=1))

res
```

## Probability of conversion detection

Given the gold SNP distribution in the genome, we computed the probability of detecting
a SNP in a window of a given size. We sampled 10000 windows of different sizes and computed the mean number of SNP detected and the number of windows with at least one SNP.

```{rprobDetect, eval=FALSE}
snp_data <- TabOfSNP

# Liste des chromosomes et de leur longueur
chrom_lengths <- list(
  Chr1 = 30427671,
  Chr2 = 19698289,
  Chr3 = 23459830,
  Chr4 = 18585056,
  Chr5 = 26975502
)

# Fonction pour créer le tableau de SNP pour chaque chromosome
create_chr_snp <- function(chr_name, chr_length, snp_data) {
  chr_df <- tibble(Chr = rep(chr_name, chr_length), Position = 1:chr_length, snp = 0)
  tmp <- snp_data$Pos[which(snp_data$Chr == chr_name & snp_data$is.Gold == TRUE)]
  chr_df$snp[chr_df$Position %in% tmp] <- 1
  return(chr_df)
}

# Génération des tableaux pour chaque chromosome
genosnp <- bind_rows(
  lapply(names(chrom_lengths), function(chr) create_chr_snp(chr, chrom_lengths[[chr]], TabOfSNP))
)

# Ajout d'une colonne ID
genosnp <- genosnp %>% dplyr::mutate(id = row_number())

# Paramètres
Lwindow <- c(20, 50, 75, 100, 200, 300, 400, 500, 600, 700, 
             800, 900, 1000, 1200, 1500, 2000, 2500, 3000, 
             4000, 5000, 8000, 10000)
nbnco <- 10000

# Initialisation des listes de résultats
LNCO <- vector("list", length(Lwindow))
Lconvertedmarkers <- vector("list", length(Lwindow))
Lnbncodetected <- vector("list", length(Lwindow))

# Boucle principale
for(j in seq_along(Lwindow)) {
  # Échantillonnage des événements nco
  nco <- sample_n(genosnp[1:(nrow(genosnp) - Lwindow[j]), ], size = nbnco, replace = FALSE)
  LNCO[[j]] <- nco

  # Calcul des positions et des SNPs convertis
  convpos <- unlist(lapply(nco$id, function(x) x:(x + Lwindow[j] - 1)))
  convsnp <- genosnp$snp[convpos]

  # Détection des événements et marquages convertis
  event <- rep(1:nbnco, each = Lwindow[j])
  Lnbncodetected[[j]] <- sum(tapply(convsnp, event, function(x) ifelse(sum(x) > 0, 1, 0)))
  Lconvertedmarkers[[j]] <- sum(convsnp)
}

# Résultats dans un tableau
res <- tibble(
  nbEventDetected = unlist(Lnbncodetected),
  SumNbConvertedMarkers = unlist(Lconvertedmarkers),
  ProbDetec = unlist(Lnbncodetected) / nbnco,
  MeanConverted = unlist(Lconvertedmarkers) / unlist(Lnbncodetected),
  Lwindow = Lwindow
)

```

```{r tlNCOres, echo=FALSE, out.width="50%",fig.align='center'}
load("Data/manipTracLengthNCO.RData")

ggplot(manipTracLengthNCO,aes(x=Lwindow,y=ProbDetec)) +
    xlab("window's size") + ylab("Probability of Detection") +
     geom_point() + theme_bw()

```

# Bibliographie


# Session info

```{r sessionInfo, echo=TRUE}
sessionInfo()
```
